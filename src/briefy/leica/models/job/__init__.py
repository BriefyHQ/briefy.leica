"""Briefy Leica Assignment model."""
from briefy.common.db.types import AwareDateTime
from briefy.leica.db import Base
from briefy.leica.models import mixins
from briefy.leica.models.job import workflows
from briefy.leica.models.job.order import Order
from briefy.leica.utils.transitions import get_transition_date
from briefy.leica.vocabularies import TypesOfSetChoices
from briefy.ws.utils.user import add_user_info_to_state_history
from datetime import datetime
from sqlalchemy import orm
from sqlalchemy import select
from sqlalchemy.ext.declarative import declared_attr
from sqlalchemy.ext.hybrid import hybrid_property
from zope.interface import implementer
from zope.interface import Interface

import colander
import sqlalchemy as sa
import sqlalchemy_utils as sautils


__summary_attributes__ = [
    'id', 'title', 'description', 'slug', 'created_at', 'updated_at', 'state',
    'number_required_assets', 'approvable', 'total_assets', 'total_approvable_assets',
    'category'
]

__listing_attributes__ = __summary_attributes__ + [
    'assignment_date', 'last_approval_date', 'submission_date', 'last_submission_date',
    'set_type', 'number_required_assets', 'category', 'scheduled_datetime'
]


def create_slug_from_order(context):
    """Create a slug for Assignment from the Order slug."""
    order_id = context.current_parameters.get('order_id')
    order = Order.get(order_id)
    total = len(order.assignments) + 1
    return '{slug}_{total:02d}'.format(slug=order.slug, total=total)


class IAssignment(Interface):
    """Marker interface for an Assignment."""


class AssignmentDates:
    """Mixin providing date-related information of a Assignment."""

    scheduled_datetime = sa.Column(
        AwareDateTime(),
        nullable=True,
        info={
            'colanderalchemy': {
                'title': 'Scheduled date for shooting',
                'missing': colander.drop,
                'typ': colander.DateTime
            }
        }
    )
    """Scheduled date time of shooting."""

    # Relevant dates
    @hybrid_property
    def assignment_date(self) -> datetime:
        """Return last assignment date for this Assignment.

        Information will be extracted from state history field.
        """
        transitions = ('assign', 'self_assign', )
        return get_transition_date(transitions, self)

    @hybrid_property
    def last_approval_date(self) -> datetime:
        """Return last QA transition date for this Assignment.

        Information will be extracted from state history field.
        """
        transitions = ('approve', 'reject', )
        return get_transition_date(transitions, self)

    @hybrid_property
    def submission_date(self) -> datetime:
        """Return first submission date date for this Assignment.

        Information will be extracted from state history field.
        """
        transitions = ('ready_for_upload', )
        return get_transition_date(transitions, self, first=True)

    @hybrid_property
    def last_submission_date(self) -> datetime:
        """Return last submission date date for this Assignment.

        Information will be extracted from state history field.
        """
        transitions = ('ready_for_upload', )
        return get_transition_date(transitions, self)


@implementer(IAssignment)
class Assignment(AssignmentDates, mixins.AssignmentBriefyRoles,
                 mixins.AssignmentFinancialInfo, mixins.LeicaMixin,
                 mixins.VersionMixin, Base):
    """An Assignment within an Order."""

    _workflow = workflows.AssignmentWorkflow

    __summary_attributes__ = __summary_attributes__
    __summary_attributes_relations__ = [
        'project', 'comments', 'location', 'professional', 'customer', 'pool', 'external_id'
    ]
    __listing_attributes__ = __listing_attributes__

    __raw_acl__ = (
        ('create', ('g:briefy_pm', 'g:briefy_finance', 'g:briefy_scout', 'g:system')),
        ('list', ('g:briefy', 'g:system')),
        ('view', ('g:briefy', 'g:system')),
        ('edit', ('g:briefy_pm', 'g:briefy_finance', 'g:briefy_scout', 'g:system')),
        ('delete', ('g:briefy_finance', 'g:system')),
    )

    __colanderalchemy_config__ = {
        'excludes': [
            'state_history', 'state', 'order', 'comments',
            'professional', 'assets', 'project', 'location',
            '_scout_manager', '_project_manager', '_qa_manager',
            '_professional_user', 'pool'
        ]
    }

    _slug = sa.Column('slug',
                      sa.String(255),
                      nullable=True,
                      index=True,
                      default=create_slug_from_order,
                      info={'colanderalchemy': {
                          'title': 'Description',
                          'typ': colander.String}}
                      )
    """Slug -- friendly id -- for the object.

    To be used in url and as human readable ID. (this should be generated by an Order)
    """

    @hybrid_property
    def slug(self) -> str:
        """Return a slug for an object.

        :return: A slug to be added to an url.
        """
        return self._slug

    @slug.setter
    def slug(self, value: str):
        """Set a new slug for this object.

        If the value is None, we generate a new one using
        :func:`briefy.common.utils.data.generate_contextual_slug`
        :param value: Value of the new slug
        """
        if self._slug:
            raise Exception('Slug should not be changed.')
        else:
            self._slug = value

    set_type = sa.Column(
        sautils.ChoiceType(TypesOfSetChoices, impl=sa.String()),
        nullable=True,
        default=None,
        info={
            'colanderalchemy': {
                'title': 'Type of Set',
                'default': colander.null,
                'missing': colander.drop,
                'typ': colander.String
            }
        }
    )
    """Type of Set when in QA.

    Define the type of set when in QA. It will be updated by the workflow.
    """

    order_id = sa.Column(
        sautils.UUIDType,
        sa.ForeignKey('orders.id'),
        nullable=False,
        info={
            'colanderalchemy': {
                'title': 'Order ID',
                'validator': colander.uuid,
                'typ': colander.String
            }
        }
    )
    """Order ID.

    Relantionship to :class:`briefy.leica.models.job.order.Order`
    """

    pool_id = sa.Column(
        sautils.UUIDType,
        sa.ForeignKey('pools.id'),
        nullable=True,
        info={
            'colanderalchemy': {
                'title': 'Pool ID',
                'validator': colander.uuid,
                'typ': colander.String,
                'missing': colander.drop,
            }
        }
    )
    """Pool ID.

    Relantionship to :class:`briefy.leica.models.job.pool.Pool`
    """

    # Professional
    professional_id = sa.Column(
        sautils.UUIDType,
        sa.ForeignKey('professionals.id'),
        nullable=True,
        info={'colanderalchemy': {
            'title': 'Professional ID',
            'validator': colander.uuid,
            'missing': colander.drop,
            'typ': colander.String}}
    )
    """Professional ID.

    Relationship with :class:`briefy.leica.models.professional.Professional`.

    Professional ID linked with this Assignment.
    """

    professional = orm.relationship(
        'Professional',
    )
    """Relationship with :class:`briefy.leica.models.professional.Professional`.

    Professional instance linked with this Assignment.
    """

    # Assets for this Assignment
    assets = orm.relationship(
        'Asset',
        backref=orm.backref('assignment'),
        lazy='dynamic'
    )
    """Assets connected to this Assignment.

    Collection of :class:`briefy.leica.models.asset.Asset`.
    """

    approvable_assets = orm.relationship(
        'Asset',
        primaryjoin='''and_(
            Asset.assignment_id == Assignment.id,
            Asset.state.in_(('approved', 'pending', 'delivered'))
        )''',
        viewonly=True

    )
    """Approvable assets connected to this Assignment.

    To be listed here, an Asset, needs to be on one of the following states:

        * approved

        * pending

        * delivered

    Collection of :class:`briefy.leica.models.asset.Asset`.
    """

    comments = orm.relationship(
        'Comment',
        foreign_keys='Comment.entity_id',
        order_by='asc(Comment.created_at)',
        primaryjoin='Comment.entity_id == Assignment.id',
        lazy='dynamic'
    )
    """Comments connected to this Assignment.

    Collection of :class:`briefy.leica.models.comment.Comment`.
    """

    submission_path = sa.Column(
        sautils.URLType,
        nullable=True,
        info={
            'colanderalchemy': {
                'title': 'Path to photographer submission',
                'validator': colander.url,
                'missing': colander.drop,
                'typ': colander.String
            }
        }
    )
    """Path to the assets submission.

    On Knack it usually pointed to a google-drive folder where
    the Professional have write-permission.
    This will be deprecated when assets upload is handled also using Leica.
    """

    project = orm.relationship(
        'Project',
        secondary="join(Order, Project, Order.project_id == Project.id)",
        secondaryjoin="Order.project_id == Project.id",
        primaryjoin="Order.id == Assignment.order_id",
        viewonly=True,
        uselist=False
    )
    """Project related to this Assignment.

    Instance of :class:`briefy.leica.models.project.Project`.
    """

    location = orm.relationship(
        'OrderLocation',
        secondary="join(Order, OrderLocation, Order.id == OrderLocation.order_id)",
        secondaryjoin="Order.id == OrderLocation.order_id",
        primaryjoin="Order.id == Assignment.order_id",
        viewonly=True,
        uselist=False
    )
    """OrderLocations related to this Assignment.

    Instance of :class:`briefy.leica.models.job.location.OrderLocation`.
    """

    @sautils.aggregated('assets', sa.Column(sa.Integer, default=0))
    def total_assets(self):
        """Total number of assets.

        Counter of the number of assets in this Assignment.
        """
        return sa.func.count('1')

    @sautils.aggregated('approvable_assets', sa.Column(sa.Integer, default=0))
    def total_approvable_assets(self):
        """Total number of assets that can be approved.

        Counter of the number of assets in this Assignment that can be approved.
        """
        return sa.func.count('1')

    @property
    def approvable(self) -> bool:
        """Check if this Assignment could be approved.

        :returns: Boolean indicating if it is possible to approve this Assignment.
        """
        approvable_assets_count = self.total_approvable_assets
        check_images = self.order.number_required_assets <= approvable_assets_count
        return check_images

    @declared_attr
    def title(cls) -> str:
        """Return the title of an Order."""
        return orm.column_property(
            select([Order.title]).where(
                Order.id == cls.order_id
            ),
        )

    @declared_attr
    def description(cls) -> str:
        """Return the description of an Order."""
        return orm.column_property(
            select([Order.description]).where(
                Order.id == cls.order_id
            ),
        )

    @declared_attr
    def customer_order_id(cls) -> str:
        """Return the customer_order_id of an Order."""
        return orm.column_property(
            select([Order.customer_order_id]).where(
                Order.id == cls.order_id
            ),
        )

    @declared_attr
    def order_slug(cls) -> str:
        """Return the order_id (slug) of an Order."""
        return orm.column_property(
            select([Order.slug]).where(
                Order.id == cls.order_id
            ),
        )

    @declared_attr
    def category(cls) -> str:
        """Return the category of an Order."""
        return orm.column_property(
            select([Order.category]).where(
                Order.id == cls.order_id
            ),
        )

    @declared_attr
    def number_required_assets(cls) -> str:
        """Return the number_required_assets of an Order."""
        return orm.column_property(
            select([Order.number_required_assets]).where(
                Order.id == cls.order_id
            ),
        )

    @hybrid_property
    def customer_approval_date(self) -> datetime:
        """Return last accept/refusal date for the parent order."""
        return self.order.customer_approval_date

    @property
    def briefing(self) -> str:
        """Return the briefing URL for the parent project."""
        return self.order.project.briefing

    @property
    def assigned(self) -> bool:
        """Return if this Assignment is assigned or not."""
        return True if (self.assignment_date and self.professional_id) else False

    def to_listing_dict(self) -> dict:
        """Return a summarized version of the dict representation of this Class.

        Used to serialize this object within a parent object serialization.
        :returns: Dictionary with fields and values used by this Class
        """
        data = super().to_listing_dict()
        data = self._apply_actors_info(data)
        return data

    def to_dict(self):
        """Return a dict representation of this object."""
        data = super().to_dict()
        data['title'] = self.title
        data['description'] = self.description
        data['briefing'] = self.briefing
        data['assignment_date'] = self.assignment_date
        data['slug'] = self.slug
        data['tech_requirements'] = self.project.tech_requirements
        data['requirements'] = self.order.requirements
        data['category'] = self.category

        # Workflow history
        add_user_info_to_state_history(self.state_history)

        # Apply actor information to data
        data = self._apply_actors_info(data)
        return data
